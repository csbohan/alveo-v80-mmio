# PCA-comp MMIO register map (test_12x2 / small config)

Generated by `sbt "runMain pca.PCACompWithMMIO"`. Top-level Verilog: `generated/PCACompWithMMIO.sv`.

All registers are **32-bit**. Byte offsets are relative to the PCA-comp base address in the BAR.

| Offset | Access | Name        | Description |
|--------|--------|-------------|-------------|
| 0x00   | W      | Control     | [0]=updateIEM, [1]=verifyIEM, [2]=indatavalid, [3]=reset |
| 0x04   | W      | rowid       | Row index (0..nrows-1). For small: 1 bit (0 or 1). |
| 0x08   | W      | iempos      | IEM component index (0..nmaxpcs-1). For small: 1 bit (0 or 1). |
| 0x0C   | W      | iemdata     | IEM row data for this block (32 bits). |
| 0x10   | W      | indata      | Input pixel row for this block (low 20 bits used; 4Ã—5-bit). |
| 0x14   | R      | Status      | [0]=out.valid (result ready). |
| 0x18   | R      | Result      | Compressed output (32 bits). **Reading this register asserts out.ready** (consumes the result). |
| 0x1C   | R      | iemdataverify | IEM readback for verification (32 bits). |

## Host flow (peek-poke testbench)

1. **Load IEM**: For each (rowid, iempos) write rowid @ 0x04, iempos @ 0x08, iemdata @ 0x0C, then write Control with bit 0 set (updateIEM=1). Clear updateIEM after.
2. **Optional verify**: Set Control bit 1 (verifyIEM), set iempos and rowid, read @ 0x1C (iemdataverify).
3. **Run**: For rowid 0..nrows-1, write rowid @ 0x04, indata @ 0x10, then write Control with bit 2 set (indatavalid=1) for one cycle, then clear.
4. **Read result**: Poll Status @ 0x14 until [0]=1, then read Result @ 0x18 (this consumes the result).

For test_12x2: nrows=2, nmaxpcs=2, width=4 (pixels per block), so two rows of input and one 32-bit result after the last row.
